jquery其实就是一堆js函数(js库)

jQuery面向用户良好的设计使得在使用过程中彻底解放了你记忆原生操作DOM的接口

jQuery中包含多个可重用的函数，用来辅助我们简化javascript开发

jQuery在半数以上并没有复杂交互的网站中得以大面积使用，因为它们需要的仅仅是一些
兼容低级浏览器而又呈现酷炫效果动画的页面。（jQuery出到3，但大公司pc端依然用1.x版本、移动端2.x版本）

jQuery改变了数百万人编写JavaScript的方式，当然部分人已经觉得时过境迁，组件化，工程化，大行其道，
但请不要忘记他的前端开发者的启蒙意义！且很多公司很多项目依然需要他!


核心全局函数：$(jQuery)
$()相当于一个函数，在函数中传入参数(参数是符合css选择器规则的字符串)，可以获取页面中任何一个标签

jQuery选择器选择上来的是一个类数组
$('div').css()  标签选择器 
实例方法：最后都作用于选择出来的标签上

jquery与原生使用区别：
jquery选择器选出来的一个组，通过jquery的方法可以对这个组集中操作，这是因为jquery内部写了很多的循环，将用户外部的省略
原生选出来的组，需要将这个组中的每一个单独操作，

$()中参数规则：
        css selector
            $('div ul li')

        jquery unique selector jquery特有规则选择器
        参考网站：http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp
        $(".wrapper ul li:first")选择第一个li
        $(".wrapper ul li:odd")奇数选择器 even偶数
        $(".wrapper ul li:eq(x)")选择第x个 当x为负值的时候，从后面向前数
        $("li[data = 'zhangfan']") 选择li下面data = "zhangfan"的这个标签元素 选择私有属性
        $("li[data$= 'zhangfan']") 选择li下面必须具备data属性的，而且必须以zhangfan结尾的标签元素 同样还可以使用 ^ !

		null、undefined、
        容错机制(当你在选择器中的参数传null，undefined 都不会报出错,即使选择了之后，没有这个东西也不会报错)
        如果没有容错机制，因为js是单线程的，这样整个程序就停了
        容错机制很好的避免了这些错误的发生

        dom对象
        参数传递原生dom对象，当你将一个获取到的原生传入$()中后，jQuery会将这个原生的dom对象包装成jQuery对象，
        通过这样包装之后就可以直接使用jquery中的方法
        var oDiv= document.getRlementById('demo')
        $(oDiv).css() 同样也是包裹

        补充：$("div ul li ").each(function(index，ele){  可以遍历ul下的里对象
            $(ele).find('span').css({color:colorArr[index]})  
            find方法  可以找ele代表的标签下的span标签
            jquery也可以实现链式调用，因为每次调用方法之后返回的都是一个jquery对象！
        }) 
        
		传递$(function(){}) 
        原生中的时间线的问题：
        DOMContentLoaded 在window.onload之前触发的事件  标志着dom加载完成
        window.onload = function(){}当所有的css html都加载完成之后，最后调用window.onload

        下面的这个，当dom加载完成之后(DOMContentLoaded),当触发DOMContentLoaded之后下面的这个就会执行
        $(function(){})
        在$()括号中放置一个函数，就是相当于绑定一个事件，事件类型就是DOMContentLoaded
        下面是上面的简写
        $(document).ready() 
        
        两个参数
        $('ul','.wrapper')  wrapper在这里充当上下文。这个选择器的意思是，在wrapper的下选择ul

    补充：$() 执行之后返回一个对象？
        jquery库在写的时候，是以一个闭包的形式(立即执行函数)来写的，也就是封闭作用域，防止影响外部变量
        (function(){
          jQuery = function(selector){
              //当我们在外部执行$('.demo')的时候，这里讲demo传给selector 然后通过调用这个函数返回下面的对象
              return new jQuery.prototype.init(selector)
          }
          jQuery.prototype.init = function(selector){
              //this = {}
              利用原型上的init函数  选出dom  并且包装成jQuery对象，返回
            if(selector.indexOf('.')! = -1){
                var dom = document.getRlementsByClassName(selector.slice(1))
            }else if(selector.indexOf('#')! = -1){
                var dom = document.getRlementById(selector.slice(1))
            }
            if(dom.length == undefined){
                this[0] = dom;
                this.length++;
            }else{
                // 基础铺垫
                for(var i = o;i<dom.length;i++){
                    this[i] = dom[i];
                    this.length++;
                }
            }
            return this;
          }
          
          //css
          jQuery.prototype.css = function (config) {
                // 对象解析
                // 循环操作每一个dom
                // 循环操作
                for (var i = 0; i < this.length; i++) {
                    for (var attr in config) {
                        this[i].style[attr] = config[attr];
                    }
                }
                // 链式操作重点
                return this;
                // 这里是拿到谁操作完成之后，又将其返回出去，方便下一次操作
            }
            // 让jQuery.prototype.init原型 执行jQuery原型
            jQuery.prototype.init.prototype = jQuery.prototype;

            window.$ = window.jQuery = jQuery
            上面这行代码的作用是，保证当代码执行完成之后jQuery这个函数不会消失，因为将jQuery挂载到全局变量下
            相当于将jQuery这个函数返回到了外部，形成了闭包，这样jQuery就不会没了
        })()


jQuery实例方法
    1:$('.demo').get() :get获得原生的dom元素
    2:$('.demo').eq(x) :选中demo中的第X个元素
    3:$('.demo').find(x) :搜索后代中的x元素
    4:$('.demo').filter()：过滤作用  找到符合条件的
    5:$('.demo').not(): 与filter用法相同作用相反，找到不符合条件的
    6:$('.demo').is('li'): 判断选中的是不是li，返回Boolean值
    7:$('.demo').has('li'):选择demo中有li的元素


dom操作 取赋值相关的方法
    .html():等同于innerHTML方法，设置或返回表格行的开始和结束标签之间的 HTML。
    .text():等同于innerTEXT方法，取出从起始位置到终止位置的内容,但它去除Html标签
    .size():等同于原生中的。length 求长度
    .addClass():增加类名
    .removeClass():删除类名
    .hasClass():判断有没有这个类名

补充小知识：并列选择器：两个选择器固定一个元素

    css() 方法设置或返回被选元素的一个或多个样式属性。

    attr()
    attr是基于：setAttribute(方法添加指定的属性，并为其赋指定的值。如果这个指定的属性已存在，则仅设置/更改值。)
               getAtteribute(方法返回指定属性名的属性值。)
    是上面两个的结合体

    prop()

注意:尽量避免直接使用行间样式。因为行间样式的权重过高，不利于响应式设计，破坏了c3和h5的方案
     prop和attr的区别:jquery认为attribute的checked selected disabled就是表示该属性初始状态的值
                     property的checked selected disabled表示该属性实时状态的值